You chose the file "C:\Users\ofcra\Google Drive\Research\RiverGrowth\load_and_solve_laplace.edp"
-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 :
    2 : // Defining the projection function to extract the expansion of the field around a tip
    3 : //////////////////////////////////////////
    4 :
    5 : real x0 = 0., y0 = 0.,
 *** Warning  The identifier y0 hide a Global identifier
 R = 0.01, WeightNorm = 0;
    6 :
    7 : real[int] a(3); // the list of coefficients of the expansion
    8 : int exponant = 2; // the precision of the exponential
    9 :
   10 : func real BaseVector(int nf, complex zf) // this defines the base vectors of the analytical field around a tip
   11 : {
   12 :   real result = 0;
   13 :
   14 :   if (nf%2 == 0)
   15 :     result = -imag(zf^(nf/2.));
   16 :   else
   17 :     result = real(zf^(nf/2.));
   18 :   return result;
   19 : }
   20 :
   21 :
   22 : func real tipfield( real[int] X, real[int] Y,real sigma,int nTips)
   23 : {
   24 :  real err = 0;
   25 :  for(int i = 0; i < nTips; i++)
   26 :     {
   27 :         real rsq = (x - X(i))^2 + (y - Y(i))^2;
   28 :         if(rsq < 2.*square(sigma))
   29 :         err += exp(-(rsq / (2.0*sigma^2)));
   30 :     }
   31 :  return err;
   32 : }
   33 :
   34 : //////////////////////////////////////////
   35 : // load the mesh and solve
   36 : //////////////////////////////////////////
   37 : // load the delaunay mesh
   38 : mesh Th = readmesh("Mesh.msh");
   39 : cout<<" Mesh reading done"<<endl;
   40 : //plot(Th, fill = 1, wait = 1);
   41 : Th = adaptmesh(Th , 1, nbvx = 500000, hmax = 0.1, nbsmooth = 100, iso = true, ratio = 1.8);
   42 : //plot(Th, fill = 1, wait = 1);
   43 : /////////////////////////////////////////
   44 : // new tip reading method
   45 : real[int, int] tips(1,1);
   46 : real[int]      angle(3);
   47 : real[int] X(1);
   48 : real[int] Y(1);
   49 : real[int] Names(1);
   50 : ifstream freefemInput1("freefem_input.dat");
   51 : int nbTips; freefemInput1 >> nbTips; // get the number of tips
   52 : tips.resize(2, nbTips);               // resize the tip array
   53 : angle.resize(nbTips);                // resize the angle array
   54 : X.resize(nbTips);
   55 : Y.resize(nbTips);
   56 : Names.resize(nbTips);
   57 : cout<< "Number of Tips: "<<nbTips<<endl;
   58 :
   59 : ifstream settings("FEM_settings.txt");
   60 : int equation; settings >> equation;
   61 : int adaptation; settings >> adaptation;
   62 :
   63 : // read in the tips
   64 : for(int i = 0;i < nbTips; i++){
   65 :     cout<< "Index: "<< i <<"  ";
   66 :     freefemInput1 >> X(i) >> Y(i) >> angle(i) >> Names(i);
   67 :     cout << "(" << X(i) << "," << Y(i) << ")" << endl;
   68 : }
   69 :
   70 :
   71 :
   72 :
   73 :
   74 :
   75 : /////////////////////////////////////////
   76 : fespace Vh(Th, P2);
   77 : fespace Vh0(Th, P0);
   78 :
   79 : Vh u, v;
   80 : Vh0 h = 1;
   81 :
   82 : real rain = 1./4;
   83 :
   84 : problem Laplace(u, v, solver = sparsesolver) =
   85 :          int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
   86 :              -int1d(Th, 3)(v)  // constant flux
   87 :              //+ on(3,u = 50) // box height
   88 :              + on(1, u=0);             // impervious apalachicola
   89 :
   90 : problem Poisson(u, v, solver = sparsesolver) =
   91 :          int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
   92 :              -int2d(Th)(rain*v)
   93 :              +on(1, u = 0)
   94 :              + on(2,u = 0)
   95 :              + on(3,u = 0);             // impervious apalachicola
   96 :
   97 : //////////////////////////////////////////
   98 :
   99 :
  100 :
  101 : // Tip field adaption
  102 : /*for(int k = 0; k < 2; k++)
  103 : {
  104 :  int nn = Th.nv;
  105 : cout << "\n\n" << Th.nv << "\n\n";
  106 :  Th = adaptmesh(Th, 0.25/(1 + 5e2 * tipfield(X, Y, 2.*R, nbTips)),
  107 :               nbvx = 2000000, IsMetric = 1, nbsmooth = 10, iso = true, ratio = 1.3);
  108 : cout << "\n\n" << Th.nv << "\n\n";
  109 :  if( abs(Th.nv - nn) <  0.1 * Th.nv ) break; // if less the 10% change stop.
  110 : }*/
  111 :
  112 : /////////////////////////////////////////
  113 :
  114 : if (equation == 0) Laplace;
  115 : if (equation == 1) Poisson;
  116 :
  117 : cout << "First solve" << endl;
  118 : /////////////////////////////////////////
  119 : // adaption
  120 :
  121 : if (adaptation == 1) {
  122 :     real error = 0.02; // 0.04
  123 :     while(h[].min >= 0.3*R)
  124 :     {
  125 :         if (equation == 0) Laplace;
  126 :         if (equation == 1) Poisson;
  127 :         Th = adaptmesh(Th, [u, 20/(1 + tipfield(X, Y, 2.*R, nbTips))], err = error, nbvx = 1000000, hmin = 0.25*ive\Research\RivﬂîΩ’Á<R, iso = true, ratio = 3);
  128 :         error = 0.5*error;
  129 :         u = u;
  130 :         h = hTriangle; // the triangle size
  131 :     }
  132 : }
  133 :
  134 : if (equation == 0) Laplace;
  135 : if (equation == 1) Poisson;
  136 :
  137 : /////////////////////////////////////////
  138 :
  139 : //plot(Th, fill = 1, wait = 1, ps = "net.eps");
  140 : //plot(u, fill = 1, wait = 1, ps = "field.eps");
  141 :
  142 : cout << "problem solved" << endl;
  143 : //////////////////////////////////////////
  144 : // find the growth rate and direction of tips
  145 : //////////////////////////////////////////
  146 : cout << "Finding the Tip coefficients" << endl;
  147 : mesh Ph;
  148 : ofstream freefemOutput("freefem_output.dat");
  149 : ofstream flowProfile("flow_profile.dat");
  150 : for(int i=0; i < nbTips; ++i)
  151 : {
  152 :     cout << "Processing Tip" << i << "  ";
  153 :     x0 = X(i); y0 = Y(i);
  154 :     //Th = splitmesh(Th, 1 + 1*((x-x0)^2+(y-y0)^2<(2*R)^2) );
  155 :     //Laplace;
  156 :     cout << "(" << x0 << "," << y0 << ") " << angle(i) << endl;
  157 :     cout << "Projecting...\n";
  158 :     Ph = trunc(Th, (sqrt((x - x0)^2 + (y - y0)^2) < 3*R));
  159 :        cout << "Ph.nv = " << Ph.nv << endl;
  160 :     fespace Wh(Ph, P2); //Wh up = u;
  161 :
  162 :     // algorithm searching for angle alpha, for which u(x0 + ring*R*sin(alpha), y0 + ring*R*cos(alpha)) = max.
  163 :     // i.e. the direction from which the flux is greatest
  164 :     real ring = 5;
  165 :     real angleRight = -pi;
  166 :     real angleLeft = pi;
  167 :     real valueRight = u(0, -ring*R);
  168 :     real valueLeft = u(0, ring*R);
  169 :     if (u(x0, y0 - ring*R) > u(x0, y0 + ring*R)) {
  170 :         angleRight = 0;
  171 :         angleLeft = 2*pi;
  172 :     }
  173 :     real angleCenter = (angleLeft + angleRight)/2;
  174 :     real valueCenter = u(x0 + ring*R*sin(angleCenter), y0 + ring*R*cos(angleCenter));
  175 :     real angleNew;
  176 :     real valueNew;
  177 :     bool newOnRight;
  178 :     for (int i = 1; i <= 64; i++) {
  179 :         //cout << angleLeft << " " << angleCenter << " " << angleRight << endl;
  180 :         //cout << valueLeft << " " << valueCenter << " " << valueRight << endl;
  181 :         if (angleCenter - angleRight > angleLeft - angleCenter) {
  182 :             newOnRight = 1;
  183 :             angleNew = (angleCenter + angleRight) / 2;
  184 :         } else {
  185 :             newOnRight = 0;
  186 :             angleNew = (angleCenter + angleLeft) / 2;
  187 :         }
  188 :         valueNew = u(x0 + ring*R*sin(angleNew), y0 + ring*R*cos(angleNew));
  189 :         if (valueNew > valueCenter) {
  190 :             if (newOnRight) {
  191 :                 angleLeft = angleCenter;
  192 :                 valueLeft = valueCenter;
  193 :             } else {
  194 :                 angleRight = angleCenter;
  195 :                 valueRight = valueCenter;
  196 :             }
  197 :             angleCenter = angleNew;
  198 :             valueCenter = valueNew;
  199 :         } else {
  200 :             if (newOnRight) {
  201 :                 angleRight = angleNew;
  202 :                 valueRight = valueNew;
  203 :             } else {
  204 :                 angleLeft = angleNew;
  205 :                 valueLeft = valueNew;
  206 :             }
  207 :         }
  208 :     }
  209 :     /*real angleCenter;
  210 :     real bestValue = 0;
  211 :     for (real angle = -pi; angle < pi; angle = angle + 2*pi/1024) {
  212 :         real value = u(x0 + ring*R*sin(angle), y0 + ring*R*cos(angle));
  213 :         if (bestValue < value) {
  214 :             angleCenter = angle;
  215 :             bestValue = value;
  216 :         }
  217 :         flowProfile << angle << "\t" << value << endl;
  218 :     }*/
  219 :     //cout << "angle = " << angleCenter * 180 / pi << endl;
  220 :
  221 :     for(int order = 1; order <= a.n; ++order){
  222 :         a[order - 1] =
  223 :         int2d(Ph)( u*exp(-(sqrt((x - x0)^2 + (y - y0)^2)/R)^exponant)
  224 :                 *BaseVector(order, exp(-angle(i)*1i)*( (x-x0) + (y-y0)*1i) ) ) /
  225 :         (int2d(Ph)(exp(-(sqrt((x-x0)^2 + (y-y0)^2)/R)^exponant)
  226 :                 *square(BaseVector(order,exp(-angle(i)*1i)*( (x-x0) + (y-y0)*1i) ) )));
  227 :         freefemOutput << a[order-1] << " ";
  228 :         cout << "a(" << order << ")=" << a[order - 1] << endl;
  229 :     }
  230 :     freefemOutput << angleCenter << " " << Names(i) << endl;
  231 :
  232 : };
  233 : //plot(Ph, fill = 1, wait = 1, ps = "circle.eps");
  234 :
  235 : /*
  236 : cout<< "Writing out the field5" << endl;
  237 : // string could be read from data file to save the field in each timestep
  238 : {
  239 : ofstream FieldFile("freefem_field.csv");
  240 : // header for matlab
  241 : FieldFile << Th.nv << " " << Th.nt << endl;
  242 : // first write out the nodes
  243 : for (int i = 0; i < Th.nv; i++)
  244 : {
  245 :  FieldFile << Th(i).x << " " << Th(i).y << " " << u(Th(i).x, Th(i).y) << endl;
  246 : }
  247 :
  248 : // then write out the mesh connectivity
  249 : for (int i = 0; i < Th.nt; i++)
  250 : {
  251 :   FieldFile << Th[i][0] << " " << Th[i][1] << " " << Th[i][2] << endl;
  252 : }
  253 : }
  254 : */ sizestack + 1024 =4020  ( 2996 )
 
  --  mesh:  Nb of Triangles =    177, Nb of Vertices 106
 Mesh reading done
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 291 , h  min 0.00241048 , h max 0.143887
     area =  1 , M area = 129.011 , M area/( |Khat| nt) 1.02384
     infiny-regulaty:  min 0.109525  max 6.50234
     anisomax  7.72809, beta max = 1.24304 min  0.555482
  --  mesh:  Nb of Triangles =    291, Nb of Vertices 167
Number of Tips: 1
Index: 0  (0.250543,0.106025)
  -- Solve :
          min 6.128e-035  max 0.018092
First solve
  -- Solve :
          min 6.128e-035  max 0.018092
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 491 , h  min 0.0033363 , h max 0.401573
     area =  1 , M area = 223.564 , M area/( |Khat| nt) 1.05153
     infiny-regulaty:  min 0.177496  max 3.11778
     anisomax  3.97905, beta max = 1.35216 min  0.728355
  --  mesh:  Nb of Triangles =    491, Nb of Vertices 254
  -- Solve :
          min 2.71029e-035  max 0.017853
  number of required edges : 0
  -- adaptmesh Regulary:  Nb triangles 896 , h  min 0.00180947 , h max 0.372632
     area =  1 , M area = 444.257 , M area/( |Khat| nt) 1.14505
     infiny-regulaty:  min 0.176383  max 3.63766
     anisomax  4.48893, beta max = 1.38925 min  0.683672
  --  mesh:  Nb of Triangles =    896, Nb of Vertices 456
  -- Solve :
          min 1.09607e-034  max 0.0178287
problem solved
Finding the Tip coefficients
Processing Tip0  (0.250543,0.106025) 1.44152
Projecting...
Ph.nv = 327
a(1)=0.0254043
a(2)=0.00158691
a(3)=0.0376352
times: compile 1.12s, execution 0.581s,  mpirank:0
 ######## We forget of deleting   71670 Nb pointer,   0Bytes  ,  mpirank 0, memory leak =0
 CodeAlloc : nb ptr  3590,  size :402864 mpirank: 0
Ok: Normal End
 try getConsole C:\Users\ofcra\Google Drive\Research\RiverGrowth\load_and_solve_laplace.edp
